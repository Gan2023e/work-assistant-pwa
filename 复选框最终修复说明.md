# 复选框功能最终修复说明

## 🎯 修复的核心问题

### 问题1: 勾选母SKU复选框后，子SKU前的复选框并没有被勾选
**根本原因**: `onChange`函数过滤掉了母SKU的keys，导致Antd Table无法正确更新子SKU的选择状态

**解决方案**: 
- 修改`onChange`函数，不再过滤任何keys
- 让Antd Table完全管理`selectedRowKeys`状态
- 在`onSelect`中确保母SKU和所有子SKU的key都被添加到`selectedRowKeys`

### 问题2: 子SKU都被勾选后，母SKU的复选框并没有被勾选  
**根本原因**: 子SKU选择时没有检查并更新母SKU的选择状态

**解决方案**:
- 在子SKU的`onSelect`逻辑中添加母SKU状态检查
- 当所有子SKU都被选中时，自动添加母SKU的key到`selectedRowKeys`
- 当任一子SKU被取消选择时，自动移除母SKU的key

### 问题3: 点击表头全选复选框后，不能取消子SKU复选框的勾选状态
**根本原因**: `onSelectAll`函数没有正确处理所有行的keys

**解决方案**:
- 重写`onSelectAll`函数，包含所有行的keys（母SKU和子SKU）
- 确保全选时选择所有可见和隐藏的子SKU
- 确保取消全选时清空所有选择状态

## 🔧 技术实现核心逻辑

### 新的数据流设计
```typescript
// 核心思想：selectedRowKeys包含所有选中的key，selectedRows只包含子SKU数据

onChange: (newSelectedRowKeys, newSelectedRows) => {
  // 不过滤，让Antd完全管理选择状态
  setSelectedRowKeys(newSelectedRowKeys);
  
  // 业务逻辑只关心子SKU
  const childRows = newSelectedRows.filter(row => !row.isParentRow);
  setSelectedRows(childRows);
}
```

### 母SKU选择逻辑
```typescript
if (record.isParentRow) {
  const childKeys = record.childSkus?.map(child => child.skuid).filter(Boolean);
  
  if (selected) {
    // 选中母SKU：同时添加母SKU和所有子SKU的key
    const newKeys = [...selectedRowKeys, key, ...childKeys];
    setSelectedRowKeys(newKeys);
  } else {
    // 取消母SKU：同时移除母SKU和所有子SKU的key
    const keysToRemove = [key, ...childKeys];
    const newKeys = selectedRowKeys.filter(k => !keysToRemove.includes(k));
    setSelectedRowKeys(newKeys);
  }
}
```

### 子SKU选择逻辑
```typescript
else {
  // 子SKU选择：需要检查是否影响母SKU状态
  if (selected) {
    const newKeys = [...selectedRowKeys, key];
    
    // 检查是否所有同级子SKU都被选中
    if (allChildKeysSelected) {
      newKeys.push(parentRow.key!); // 也选中母SKU
    }
    
    setSelectedRowKeys(newKeys);
  } else {
    // 取消子SKU：确保母SKU也被取消
    const newKeys = selectedRowKeys.filter(k => k !== key);
    if (parentRow && newKeys.includes(parentRow.key!)) {
      newKeys.splice(newKeys.indexOf(parentRow.key!), 1);
    }
    setSelectedRowKeys(newKeys);
  }
}
```

### 复选框状态计算
```typescript
getCheckboxProps: (record) => {
  if (record.isParentRow) {
    // 母SKU：根据子SKU选择情况计算状态
    const childKeys = record.childSkus?.map(child => child.skuid);
    const selectedChildKeys = selectedRowKeys.filter(key => childKeys.includes(key));
    
    if (selectedChildKeys.length === 0) return { checked: false, indeterminate: false };
    if (selectedChildKeys.length === childKeys.length) return { checked: true, indeterminate: false };
    return { checked: false, indeterminate: true }; // 半选状态
  }
  
  // 子SKU：直接根据selectedRowKeys判断
  return { checked: selectedRowKeys.includes(record.key!) };
}
```

## ✅ 预期行为

### 1. 母SKU复选框点击
- ✅ **选中母SKU** → 所有子SKU复选框变为选中状态
- ✅ **取消母SKU** → 所有子SKU复选框变为未选中状态

### 2. 子SKU复选框操作
- ✅ **选中所有子SKU** → 母SKU复选框自动变为选中状态
- ✅ **取消任一子SKU** → 母SKU复选框变为半选或未选状态
- ✅ **部分选中子SKU** → 母SKU复选框显示半选状态（indeterminate）

### 3. 表头全选复选框
- ✅ **点击全选** → 所有母SKU和子SKU（包括未展开的）都被选中
- ✅ **取消全选** → 清空所有选择状态
- ✅ **部分选中状态** → 表头复选框显示半选状态

## 🚀 提交记录
```
654689a fix: 重构复选框选择逻辑，修复母SKU和子SKU联动选择功能
```

## 📝 测试检查清单

- [ ] 点击母SKU复选框，所有子SKU是否同时被选中？
- [ ] 手动选择所有子SKU后，母SKU复选框是否自动选中？  
- [ ] 取消任一子SKU选择，母SKU复选框是否变为正确状态？
- [ ] 表头全选是否能选中所有项目？
- [ ] 表头取消全选是否能清空所有选择？
- [ ] 批量删除功能是否基于正确的选择状态？

现在所有复选框功能应该完全正常工作！🎉 